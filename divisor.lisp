(declaim (ftype (function * (values (vector (integer 0 #.most-positive-fixnum)) &optional))
                enum-divisors))
(defun enum-divisors (x)
  "Enumerates all the divisors of X. Note that the returned vector is NOT
sorted."
  (declare ((integer 0 #.most-positive-fixnum) x))
  (let* ((sqrt (isqrt x))
         (res (make-array (isqrt sqrt) ; FIXME: sets the initial size to x^1/4
                          :element-type '(integer 0 #.most-positive-fixnum)
                          :fill-pointer 0)))
    (loop for i from 1 to sqrt
          do (multiple-value-bind (quot rem) (floor x i)
               (when (zerop rem)
                 (vector-push-extend i res)
                 (unless (= i quot)
                   (vector-push-extend quot res)))))
    res))

;; (defun enum-divisors (n)
;;   "Returns the increasing list of all divisors of N."
;;   (declare (optimize (speed 3))
;;            ((integer 1 #.most-positive-fixnum) n))
;;   (if (= n 1)
;;       (list 1)
;;       (let* ((root (isqrt n))
;;              (res (list 1)))
;;         (labels ((%enum (i first-half second-half)
;;                    (declare ((integer 1 #.most-positive-fixnum) i))
;;                    (if (< root i)
;;                        (setf (cdr first-half) second-half)
;;                        (multiple-value-bind (quot rem) (floor n i)
;;                          (if (zerop rem)
;;                              (progn
;;                                (setf (cdr first-half) (list i))
;;                                (setf second-half (cons quot second-half))
;;                                (%enum (1+ i) (cdr first-half) second-half))
;;                              (%enum (1+ i) first-half second-half)))))
;;                  (%enum-for-square (i first-half second-half)
;;                    (declare ((integer 1 #.most-positive-fixnum) i))
;;                    (if (= root i)
;;                        (setf (cdr first-half) (cons i second-half))
;;                        (multiple-value-bind (quot rem) (floor n i)
;;                          (if (zerop rem)
;;                              (progn
;;                                (setf (cdr first-half) (list i))
;;                                (setf second-half (cons quot second-half))
;;                                (%enum-for-square (1+ i) (cdr first-half) second-half))
;;                              (%enum-for-square (1+ i) first-half second-half))))))
;;           (if (= (* root root) n)
;;               (%enum-for-square 2 res (list n))
;;               (%enum 2 res (list n)))
;;           res))))
