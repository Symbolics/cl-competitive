(setf *print-circle* t)

;; Treap with implicit key for updating and querying interval.

(declaim (inline op))
(defun op (a b)
  (min a b))

(defconstant +op-identity+ most-positive-fixnum)

(defconstant +updater-identity+ 0)

(declaim (inline updater-op))
(defun updater-op (a b)
  "Is the operator to compute and update LAZY value."
  (+ a b))

(declaim (inline modifier-op))
(defun modifier-op (a b size)
  "Is the operator to update ACCUMULATOR based on LAZY value."
  (declare (ignore size))
  (+ a b))

(defstruct (itreap (:constructor %make-itreap (value priority &key left right (count 1) (accumulator +op-identity+) (lazy +updater-identity+) reversed))
                  (:copier nil)
                  (:conc-name %itreap-))
  (value +op-identity+ :type fixnum)
  (accumulator +op-identity+ :type fixnum) ; e.g. MIN, MAX, SUM, ...
  (lazy +updater-identity+ :type fixnum)
  (reversed nil :type boolean)
  (priority 0 :type (integer 0 #.most-positive-fixnum))
  (count 1 :type (integer 0 #.most-positive-fixnum))
  (left nil :type (or null itreap))
  (right nil :type (or null itreap)))

(declaim (inline itreap-count))
(defun itreap-count (itreap)
  (declare ((or null itreap) itreap))
  (if itreap
      (%itreap-count itreap)
      0))

(declaim (inline itreap-accumulator))
(defun itreap-accumulator (itreap)
  (declare ((or null itreap) itreap))
  (if itreap
      (%itreap-accumulator itreap)
      +op-identity+))

(declaim (inline update-count))
(defun update-count (itreap)
  (declare (itreap itreap))
  (setf (%itreap-count itreap)
        (+ 1
           (itreap-count (%itreap-left itreap))
           (itreap-count (%itreap-right itreap)))))

(declaim (inline update-accumulator))
(defun update-accumulator (itreap)
  (declare (itreap itreap))
  (setf (%itreap-accumulator itreap)
        (if (%itreap-left itreap)
            (if (%itreap-right itreap)
                (let ((mid (op (%itreap-accumulator (%itreap-left itreap))
                               (%itreap-value itreap))))
                  (declare (dynamic-extent mid))
                  (op mid (%itreap-accumulator (%itreap-right itreap))))
                (op (%itreap-accumulator (%itreap-left itreap))
                    (%itreap-value itreap)))
            (if (%itreap-right itreap)
                (op (%itreap-value itreap)
                    (%itreap-accumulator (%itreap-right itreap)))
                (%itreap-value itreap)))))

(declaim (inline force-self))
(defun force-self (itreap)
  (declare (itreap itreap))
  (update-count itreap)
  (update-accumulator itreap))

(declaim (inline force-down))
(defun force-down (itreap)
  (declare (itreap itreap))
  (when (%itreap-reversed itreap)
    (setf (%itreap-reversed itreap) nil)
    (rotatef (%itreap-left itreap) (%itreap-right itreap))
    (let ((left (%itreap-left itreap)))
      (when left
        (setf (%itreap-reversed left) (not (%itreap-reversed left)))))
    (let ((right (%itreap-right itreap)))
      (when right
        (setf (%itreap-reversed right) (not (%itreap-reversed right))))))
  (unless (eql +updater-identity+ (%itreap-lazy itreap))
    (when (%itreap-left itreap)
      (setf (%itreap-lazy (%itreap-left itreap))
            (updater-op (%itreap-lazy (%itreap-left itreap))
                        (%itreap-lazy itreap)))
      (setf (%itreap-accumulator (%itreap-left itreap))
            (modifier-op (%itreap-accumulator (%itreap-left itreap))
                         (%itreap-lazy itreap)
                         (%itreap-count (%itreap-left itreap)))))
    (when (%itreap-right itreap)
      (setf (%itreap-lazy (%itreap-right itreap))
            (updater-op (%itreap-lazy (%itreap-right itreap))
                        (%itreap-lazy itreap)))
      (setf (%itreap-accumulator (%itreap-right itreap))
            (modifier-op (%itreap-accumulator (%itreap-right itreap))
                         (%itreap-lazy itreap)
                         (%itreap-count (%itreap-right itreap)))))
    (setf (%itreap-value itreap)
          (modifier-op (%itreap-value itreap)
                       (%itreap-lazy itreap)
                       1))
    (setf (%itreap-lazy itreap) +updater-identity+)))

(defun itreap-split (itreap index)
  "Destructively splits the ITREAP into two nodes [0, INDEX) and [INDEX, N), where N
  is the number of elements of the ITREAP."
  (declare ((integer 0 #.most-positive-fixnum) index))
  (unless itreap
    (return-from itreap-split (values nil nil)))
  (force-down itreap)
  (let ((implicit-key (1+ (itreap-count (%itreap-left itreap)))))
    (if (< index implicit-key)
        (multiple-value-bind (left right)
            (itreap-split (%itreap-left itreap) index)
          (setf (%itreap-left itreap) right)
          (force-self itreap)
          (values left itreap))
        (multiple-value-bind (left right)
            (itreap-split (%itreap-right itreap) (- index implicit-key))
          (setf (%itreap-right itreap) left)
          (force-self itreap)
          (values itreap right)))))

(defun itreap-merge (left right)
  "Destructively merges two ITREAPs."
  (declare ((or null itreap) left right))
  (cond ((null left) (when right (force-down right) (force-self right)) right)
        ((null right) (when left (force-down left) (force-self left)) left)
        (t (force-down left)
           (force-down right)
           (if (> (%itreap-priority left) (%itreap-priority right))
               (progn
                 (setf (%itreap-right left)
                       (itreap-merge (%itreap-right left) right))
                 (force-self left)
                 left)
               (progn
                 (setf (%itreap-left right)
                       (itreap-merge left (%itreap-left right)))
                 (force-self right)
                 right)))))

(define-condition invalid-itreap-index-error (type-error)
  ((itreap :initarg :itreap :reader invalid-itreap-index-error-itreap)
   (index :initarg :index :reader invalid-itreap-index-error-index))
  (:report
   (lambda (condition stream)
     (format stream "Invalid index ~W for itreap ~W."
             (invalid-itreap-index-error-index condition)
             (invalid-itreap-index-error-itreap condition)))))

(declaim (inline itreap-insert))
(defun itreap-insert (itreap index obj)
  "Destructively inserts OBJ into ITREAP at INDEX."
  (declare ((or null itreap) itreap)
           ((integer 0 #.most-positive-fixnum) index))
  (unless (<= index (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index index))
  (let ((obj-itreap (%make-itreap obj (random most-positive-fixnum))))
    (multiple-value-bind (left right)
        (itreap-split itreap index)
      (itreap-merge (itreap-merge left obj-itreap) right))))

(defun itreap-map (function itreap)
  "Successively applies FUNCTION to ITREAP[0], ..., ITREAP[SIZE-1]."
  (declare (function function))
  (when itreap
    (force-down itreap)
    (itreap-map function (%itreap-left itreap))
    (funcall function (%itreap-value itreap))
    (itreap-map function (%itreap-right itreap))
    (force-self itreap)))

(defmethod print-object ((object itreap) stream)
  (print-unreadable-object (object stream :type t)
    (let ((size (itreap-count object))
          (index 0))
      (declare ((integer 0 #.most-positive-fixnum) index))
      (itreap-map (lambda (x)
                   (princ x stream)
                   (incf index)
                   (when (< index size)
                     (write-char #\  stream)))
                 object))))

(defmacro do-itreap ((var itreap &optional result) &body body)
  "Successively binds ITREAP[0], ..., ITREAP[SIZE-1] to VAR and executes BODY."
  `(block nil
     (itreap-map (lambda (,var) ,@body) ,itreap)
     ,result))

(defun itreap (&rest args)
  ;; TODO: Currently takes O(nlog(n)) time though it can be reduced to O(n). Use
  ;; MAKE-ITREAP for now.
  (labels ((recurse (list position itreap)
             (declare ((integer 0 #.most-positive-fixnum) position))
             (if (null list)
                 itreap
                 (recurse (cdr list)
                          (1+ position)
                          (itreap-insert itreap position (car list))))))
    (recurse args 0 nil)))

(defun make-itreap (size)
  "Makes a treap of SIZE in O(SIZE) time. The values are filled with the
identity element."
  (labels ((heapify (top)
             (when top
               (let ((prioritized-node top))
                 (when (and (%itreap-left top)
                            (> (%itreap-priority (%itreap-left top))
                               (%itreap-priority prioritized-node)))
                   (setq prioritized-node (%itreap-left top)))
                 (when (and (%itreap-right top)
                            (> (%itreap-priority (%itreap-right top))
                               (%itreap-priority prioritized-node)))
                   (setq prioritized-node (%itreap-right top)))
                 (unless (eql prioritized-node top)
                   (rotatef (%itreap-priority prioritized-node)
                            (%itreap-priority top))
                   (heapify prioritized-node)))))
           (build (l r)
             (declare ((integer 0 #.most-positive-fixnum) l r))
             (if (= l r)
                 nil
                 (let* ((mid (ash (+ l r) -1))
                        (node (%make-itreap +op-identity+
                                           (random most-positive-fixnum))))
                   (setf (%itreap-left node) (build l mid))
                   (setf (%itreap-right node) (build (+ mid 1) r))
                   (heapify node)
                   (update-count node)
                   node))))
    (build 0 size)))

(declaim (inline itreap-delete))
(defun itreap-delete (itreap index)
  (declare ((integer 0 #.most-positive-fixnum) index))
  (unless (< index (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index index))
  (multiple-value-bind (itreap1 itreap2)
      (itreap-split itreap (1+ index))
    (multiple-value-bind (itreap1 _)
        (itreap-split itreap1 index)
      (declare (ignore _))
      (itreap-merge itreap1 itreap2))))

(declaim (inline itreap-ref))
(defun itreap-ref (itreap index)
  (declare ((integer 0 #.most-positive-fixnum) index))
  (unless (< index (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index index))
  (labels ((%ref (itreap index)
             (declare ((integer 0 #.most-positive-fixnum) index))
             (force-down itreap)
             (prog1
                 (let ((left-count (itreap-count (%itreap-left itreap))))
                   (cond ((< index left-count)
                          (%ref (%itreap-left itreap) index))
                         ((> index left-count)
                          (%ref (%itreap-right itreap) (- index left-count 1)))
                         (t (%itreap-value itreap))))
               (force-self itreap))))
    (%ref itreap index)))

(declaim (inline (setf itreap-ref)))
(defun (setf itreap-ref) (new-value itreap index)
  (declare ((integer 0 #.most-positive-fixnum) index))
  (unless (< index (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index index))
  (labels ((%set (itreap index)
             (declare ((integer 0 #.most-positive-fixnum) index))
             (force-down itreap)
             (prog1
                 (let ((left-count (itreap-count (%itreap-left itreap))))
                   (cond ((< index left-count)
                          (%set (%itreap-left itreap) index))
                         ((> index left-count)
                          (%set (%itreap-right itreap) (- index left-count 1)))
                         (t (setf (%itreap-value itreap) new-value))))
               (force-self itreap))))
    (%set itreap index)
    new-value))

(defun copy-itreap (itreap)
  "For development. Recursively copies the whole ITREAPs."
  (if (null itreap)
      nil
      (%make-itreap (%itreap-value itreap)
                   (%itreap-priority itreap)
                   :left (copy-itreap (%itreap-left itreap))
                   :right (copy-itreap (%itreap-right itreap))
                   :count (%itreap-count itreap)
                   :accumulator (%itreap-accumulator itreap)
                   :lazy (%itreap-lazy itreap)
                   :reversed (%itreap-reversed itreap))))

;; FIXME: might be problematic when two priorities collide.
(declaim (inline itreap-query))
(defun itreap-query (itreap l r)
  (declare ((integer 0 #.most-positive-fixnum) l r))
  (unless (<= l r (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))
  (if (= l r)
      +op-identity+
      (multiple-value-bind (itreap-0-l itreap-l-n)
          (itreap-split itreap l)
        (multiple-value-bind (itreap-l-r itreap-r-n)
            (itreap-split itreap-l-n (- r l))
          (prog1 (%itreap-accumulator itreap-l-r)
            (itreap-merge itreap-0-l (itreap-merge itreap-l-r itreap-r-n)))))))

;; Below is faster but hard to maintain
;; (defun itreap-query (itreap &optional (start 0) end)
;;   "Queries the sum of the half-open interval specified by the index: [START,
;; END). If END is not given, it is assumed to be the length of ITREAP]."
;;   (declare ((integer 0 #.most-positive-fixnum) start)
;;            ((or null (integer 0 #.most-positive-fixnum)) end))
;;   (if (zerop start)
;;       (if (null end)
;;           (itreap-accumulator itreap)
;;           (if (> end (itreap-count itreap))
;;               (error 'invalid-itreap-index-error :itreap itreap :index (cons 0 end))
;;               (multiple-value-bind (itreap-0-r itreap-r-n)
;;                   (itreap-split itreap end)
;;                 (prog1 (itreap-accumulator itreap-0-r)
;;                   (itreap-merge itreap-0-r itreap-r-n)))))
;;       (if (null end)
;;           (if (> start (itreap-count itreap))
;;               (error 'invalid-itreap-index-error :itreap itreap :index (cons start (itreap-count itreap)))
;;               (multiple-value-bind (itreap-0-l itreap-l-n)
;;                   (itreap-split itreap start)
;;                 (prog1 (itreap-accumulator itreap-l-n)
;;                   (itreap-merge itreap-0-l itreap-l-n))))
;;           (progn
;;             (unless (<= start end (itreap-count itreap))
;;               (error 'invalid-itreap-index-error :itreap itreap :index (cons start end)))
;;             (multiple-value-bind (itreap-0-l itreap-l-n)
;;                 (itreap-split itreap start)
;;               (multiple-value-bind (itreap-l-r itreap-r-n)
;;                   (itreap-split itreap-l-n (- end start))
;;                 (prog1 (itreap-accumulator itreap-l-r)
;;                   (itreap-merge itreap-0-l (itreap-merge itreap-l-r itreap-r-n)))))))))

(declaim (inline itreap-reverse))
(defun itreap-reverse (itreap l r)
  (declare ((integer 0 #.most-positive-fixnum) l r))
  (unless (<= l r (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))
  (multiple-value-bind (itreap-0-l itreap-l-n)
      (itreap-split itreap l)
    (multiple-value-bind (itreap-l-r itreap-r-n)
        (itreap-split itreap-l-n (- r l))
      (setf (%itreap-reversed itreap-l-r) (not (%itreap-reversed itreap-l-r)))
      (itreap-merge itreap-0-l (itreap-merge itreap-l-r itreap-r-n)))))

(declaim (inline itreap-update))
(defun itreap-update (itreap x l r)
  "Updates ITREAP[i] := (OP ITREAP[i] X) for all i in [l, r)"
  (declare ((integer 0 #.most-positive-fixnum) l r))
  (unless (<= l r (itreap-count itreap))
    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))
  (multiple-value-bind (itreap-0-l itreap-l-n)
      (itreap-split itreap l)
    (multiple-value-bind (itreap-l-r itreap-r-n)
        (itreap-split itreap-l-n (- r l))
      (when itreap-l-r
        (setf (%itreap-lazy itreap-l-r)
              (updater-op (%itreap-lazy itreap-l-r) x)))
      (itreap-merge itreap-0-l (itreap-merge itreap-l-r itreap-r-n)))))

(declaim (inline itreap-bisect-left))
(defun itreap-bisect-left (threshold itreap order)
  "Receives a **sorted** treap and returns the smallest index that satisfies
ITREAP[index] >= THRESHOLD, where >= is the complement of ORDER. Returns the
size of ITREAP if ITREAP[size-1] < THRESHOLD. The time complexity is O(log(n))."
  (declare (function order))
  (labels ((recur (count itreap)
             (declare ((integer 0 #.most-positive-fixnum) count))
             (cond ((null itreap) nil)
                   ((funcall order (%itreap-value itreap) threshold)
                    (recur count (%itreap-right itreap)))
                   (t
                    (let ((left-count (- count (itreap-count (%itreap-right itreap)) 1)))
                      (or (recur left-count (%itreap-left itreap))
                          left-count))))))
    (or (recur (itreap-count itreap) itreap)
        (itreap-count itreap))))
