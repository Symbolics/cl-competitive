;;;
;;; double-ended queue (ring buffer)
;;;

(define-condition deque-empty-error (simple-error)
  ((queue :initarg :queue :reader deque-empty-error-queue))
  (:report
   (lambda (condition stream)
     (format stream "Attempted to pop empty deque ~W" (deque-empty-error-queue condition)))))

(define-condition deque-full-error (simple-error)
  ((queue :initarg :queue :reader deque-full-error-queue)
   (item :initarg :item :reader deque-full-error-item))
  (:report
   (lambda (condition stream)
     (format stream "Attempted to push item ~W to full deque ~W"
             (deque-full-error-item condition)
             (deque-full-error-queue condition)))))

(defmacro define-deque (name &key (element-type 'fixnum))
  (let ((push-front (intern (format nil "~A-PUSH-FRONT" name)))
        (push-back (intern (format nil "~A-PUSH-BACK" name)))
        (pop-front (intern (format nil "~A-POP-FRONT" name)))
        (pop-back (intern (format nil "~A-POP-BACK" name)))
        (data-getter (intern (format nil "~A-DATA" name)))
        (front-getter (intern (format nil "~A-FRONT" name)))
        (end-getter (intern (format nil "~A-END" name)))
        (constructor (intern (format nil "MAKE-~A" name))))
    `(progn
       (defstruct (,name (:constructor ,constructor
                             (size &aux
                                   (data (progn
                                           (check-type size (integer 1))
                                           (make-array (+ 1 size) :element-type ',element-type)))))
                         (:copier nil)
                         (:predicate nil))
         (data nil :type (simple-array ,element-type (*)))
         (front 0 :type (integer 0 #.most-positive-fixnum))
         (end 1 :type (integer 0 #.most-positive-fixnum)))

       (declaim (inline ,push-front))
       (defun ,push-front (obj ,name)
         (symbol-macrolet ((front (,front-getter ,name))
                           (end (,end-getter ,name))
                           (data (,data-getter ,name)))
           (when (= front end)
             (error 'deque-full-error :item obj :queue ,name))
           (let* ((size (length data))
                  (next (mod (- front 1) size)))
             (setf (aref data front) obj)
             (setf front next)
             ,name)))

       (declaim (inline ,pop-front))
       (defun ,pop-front (,name)
         (symbol-macrolet ((front (,front-getter ,name))
                           (end (,end-getter ,name)))
           (let* ((data (,data-getter ,name))
                  (size (length data))
                  (next (mod (+ front 1) size)))
             (when (= next end)
               (error 'deque-empty-error :queue ,name))
             (setq front next)
             (aref data next))))

       (declaim (inline ,push-back))
       (defun ,push-back (obj ,name)
         (symbol-macrolet ((front (,front-getter ,name))
                           (end (,end-getter ,name))
                           (data (,data-getter ,name)))
           (when (= front end)
             (error 'deque-full-error :item obj :queue ,name))
           (let* ((size (length data))
                  (next (mod (+ end 1) size)))
             (setf (aref data end) obj)
             (setq end next)
             ,name)))

       (declaim (inline ,pop-back))
       (defun ,pop-back (,name)
         (symbol-macrolet ((front (,front-getter ,name))
                           (end (,end-getter ,name)))
           (let* ((data (,data-getter ,name))
                  (size (length data))
                  (next (mod (- end 1) size)))
             (when (= front next)
               (error 'deque-empty-error :queue ,name))
             (setq end next)
             (aref data next)))))))

(define-deque deque :element-type fixnum)
