;;;
;;; Minimum cost flow by capacity scaling (O(FElogV))
;;;

(setf *print-circle* t)

(defconstant +inf-distance+ most-positive-fixnum)

(defstruct (edge (:constructor %make-edge))
  (to nil :type (integer 0 #.most-positive-fixnum))
  (capacity 0 :type (integer 0 #.most-positive-fixnum))
  (cost 0 :type fixnum)
  (reversed nil :type (or null edge)))

(defun push-edge (from-idx to-idx capacity cost graph)
  "FROM-IDX, TO-IDX := index of vertex
GRAPH := vector of list of all the edges that goes from the vertex"
  (declare ((simple-array list (*)) graph)
           ((integer 0 #.most-positive-fixnum) cost))
  (let* ((dep (%make-edge :to to-idx :capacity capacity :cost cost))
         (ret (%make-edge :to from-idx :capacity 0 :cost (- cost) :reversed dep)))
    (setf (edge-reversed dep) ret)
    (push dep (aref graph from-idx))
    (push ret (aref graph to-idx))))

;; binary heap for Dijkstra's algorithm
(defstruct (fheap (:constructor make-fheap
                          (size
                           &aux (costs (make-array (1+ size) :element-type 'fixnum))
                                (vertices (make-array (1+ size) :element-type 'fixnum)))))
  (costs nil :type (simple-array fixnum (*)) :read-only t)
  (vertices nil :type (simple-array fixnum (*)) :read-only t)
  (next-position 1 :type (integer 1 #.most-positive-fixnum)))

(declaim (inline fheap-push))
(defun fheap-push (cost vertex fheap)
  (symbol-macrolet ((next-position (fheap-next-position fheap)))
    (let ((costs (fheap-costs fheap))
          (vertices (fheap-vertices fheap)))
      (labels ((update (pos)
                 (unless (= pos 1)
                   (let ((parent-pos (ash pos -1)))
                     (when (< (aref costs pos) (aref costs parent-pos))
                       (rotatef (aref costs pos) (aref costs parent-pos))
                       (rotatef (aref vertices pos) (aref vertices parent-pos))
                       (update parent-pos))))))
        (setf (aref costs next-position) cost
              (aref vertices next-position) vertex)
        (update next-position)
        (incf next-position)
        fheap))))

(declaim (inline fheap-pop))
(defun fheap-pop (fheap)
  (symbol-macrolet ((next-position (fheap-next-position fheap)))
    (let ((costs (fheap-costs fheap))
          (vertices (fheap-vertices fheap)))
      (labels ((update (pos)
                 (declare ((integer 1 #.most-positive-fixnum) pos))
                 (let* ((child-pos1 (+ pos pos))
                        (child-pos2 (1+ child-pos1)))
                   (when (<= child-pos1 next-position)
                     (if (<= child-pos2 next-position)
                         (if (< (aref costs child-pos1) (aref costs child-pos2))
                             (unless (< (aref costs pos) (aref costs child-pos1))
                               (rotatef (aref costs pos) (aref costs child-pos1))
                               (rotatef (aref vertices pos) (aref vertices child-pos1))
                               (update child-pos1))
                             (unless (< (aref costs pos) (aref costs child-pos2))
                               (rotatef (aref costs pos) (aref costs child-pos2))
                               (rotatef (aref vertices pos) (aref vertices child-pos2))
                               (update child-pos2)))
                         (unless (< (aref costs pos) (aref costs child-pos1))
                           (rotatef (aref costs pos) (aref costs child-pos1))
                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))
        (if (= next-position 1)
            (error "No element in heap.")
            (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))
              (decf next-position)
              (setf (aref costs 1) (aref costs next-position)
                    (aref vertices 1) (aref vertices next-position))
              (update 1)))))))

(declaim (inline fheap-empty-p))
(defun fheap-empty-p (fheap)
  (= (fheap-next-position fheap) 1))

(declaim (inline fheap-reinitialize))
(defun fheap-reinitialize (heap)
  (setf (fheap-next-position heap) 1)
  heap)

(define-condition not-enough-capacity-error (simple-error)
  ((graph :initarg :graph :reader not-enough-capacity-error-graph)
   (flow :initarg :flow :reader not-enough-capacity-error-flow))
  (:report
   (lambda (c s)
     (format s "Cannot flows ~A units in the graph ~A due to not enough capacity."
             (not-enough-capacity-error-flow c)
             (not-enough-capacity-error-graph c)))))

(defun min-cost-flow (src-idx dest-idx flow graph &key edges)
  "Returns the minimum cost to flows FLOW units from SRC-IDX to DEST-IDX in
GRAPH. Destructively modifies GRAPH.

EDGES := nil | the number of edges (assumed to be (size of GRAPH)^2 if NIL)"
  (declare ((integer 0 #.most-positive-fixnum) flow)
           ((simple-array list (*)) graph))
  (macrolet ((with-fixnum (form)
               (reduce (lambda (f1 f2) `(,(car form) (the fixnum ,f1) (the fixnum ,f2)))
		       (cdr form))))
    (let* ((size (length graph))
           (edges (or edges (* size size)))
           (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))
           (prev-edges (make-array size :element-type 'edge))
           (potential (make-array size :element-type 'fixnum :initial-element 0))
           (dist (make-array size :element-type 'fixnum))
           (pqueue (make-fheap edges))
           (res 0))
      (declare (fixnum edges res))
      (loop while (> flow 0)
            do (fill dist +inf-distance+)
               (setf (aref dist src-idx) 0)
               (fheap-reinitialize pqueue)
               (fheap-push 0 src-idx pqueue)
               (loop until (fheap-empty-p pqueue)
                     do (multiple-value-bind (cost v) (fheap-pop pqueue)
                          (declare (fixnum cost v))
                          (when (<= cost (aref dist v))
                            (dolist (edge (aref graph v))
                              (let* ((next-v (edge-to edge))
                                     (next-cost (with-fixnum
                                                    (+ (aref dist v)
                                                       (edge-cost edge)
                                                       (aref potential v)
                                                       (- (aref potential next-v))))))
                                (when (and (> (edge-capacity edge) 0)
                                           (> (aref dist next-v) next-cost))
                                  (setf (aref dist next-v) next-cost
                                        (aref prev-vertices next-v) v
                                        (aref prev-edges next-v) edge)
                                  (fheap-push next-cost next-v pqueue)))))))
               (if (= (aref dist dest-idx) +inf-distance+)
                   (error 'not-enough-capacity-error :flow flow :graph graph)
                   (let ((max-flow flow))
                     (declare (fixnum max-flow))
                     (dotimes (v size)
                       (incf (aref potential v) (aref dist v)))
                     (do ((v dest-idx (aref prev-vertices v)))
                         ((= v src-idx))
                       (setf max-flow (min max-flow (edge-capacity (aref prev-edges v)))))
                     (decf flow max-flow)
                     (incf res (the fixnum (* max-flow (aref potential dest-idx))))
                     (do ((v dest-idx (aref prev-vertices v)))
                         ((= v src-idx))
                       (decf (edge-capacity (aref prev-edges v)) max-flow)
                       (incf (edge-capacity (edge-reversed (aref prev-edges v))) max-flow)))))
      res)))

;; For test
(progn
  (defparameter *graph* (make-array '(5) :element-type 'edge :initial-element nil))
  (push-edge 0 1 10 2 *graph*)
  (push-edge 0 2 2 4 *graph*)
  (push-edge 1 2 6 6 *graph*)
  (push-edge 1 3 6 2 *graph*)
  (push-edge 3 2 3 3 *graph*)
  (push-edge 3 4 8 6 *graph*)
  (push-edge 2 4 5 2 *graph*)
  (assert (= 80 (min-cost-flow 0 4 9 *graph*)))
  (assert (= 0 (min-cost-flow 0 4 0 *graph*)))
  (block ok
    (handler-bind ((not-enough-capacity-error (lambda (c) (return-from ok c))))
      (min-cost-flow 0 4 90 *graph*)
      (error "No error signaled."))))
