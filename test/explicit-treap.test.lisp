(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../explicit-treap.lisp"))

(use-package :test-util)

(defun treap-priority (treap)
  (declare ((or null treap) treap))
  (if (null treap)
      0
      (%treap-priority treap)))

(defun treap-sane-p (treap)
  (or (null treap)
      (and (>= (%treap-priority treap)
               (treap-priority (%treap-left treap)))
           (>= (%treap-priority treap)
               (treap-priority (%treap-right treap)))
           (= (%treap-count treap)
              (+ 1
                 (treap-count (%treap-left treap))
                 (treap-count (%treap-right treap))))
           (= (%treap-accumulator treap)
              (+ (%treap-value treap)
                 (treap-accumulator (%treap-left treap))
                 (treap-accumulator (%treap-right treap))))
           (treap-sane-p (%treap-left treap))
           (treap-sane-p (%treap-right treap)))))

(defun copy-treap (treap)
  "For development. Recursively copies the whole TREAP."
  (declare ((or null treap) treap))
  (if (null treap)
      nil
      (%make-treap (%treap-key treap)
                  (%treap-priority treap)
                  (%treap-value treap)
                  :accumulator (%treap-accumulator treap)
                  :left (copy-treap (%treap-left treap))
                  :right (copy-treap (%treap-right treap))
                  :count (%treap-count treap))))

(declaim (notinline make-treap treap-insert))

(with-test (:name explicit-treap-sanity)
  (loop repeat 10
        do (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10))))
           (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9))))
           (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17))))
           (assert (treap-sane-p (make-treap #(1 2 3 4))))
           (assert (treap-sane-p (make-treap #(1))))
           (assert (treap-sane-p nil))))

(with-test (:name explicit-treap-bisection)
  (let ((treap (treap-insert (treap-insert (treap-insert nil 20 1 :order #'>) 40 4 :order #'>) 50 3 :order #'>)))
    (assert (null (treap-bisect-right-1 treap 51 :order #'>)))
    (assert (equal '(50 3) (multiple-value-list (treap-bisect-right-1 treap 50 :order #'>))))
    (assert (= 50 (treap-bisect-right-1 treap 49 :order #'>)))
    (assert (= 40 (treap-bisect-right-1 treap 40 :order #'>)))
    (assert (= 20 (treap-bisect-right-1 treap 0 :order #'>)))
    (assert (equal '(50 3) (multiple-value-list (treap-bisect-left treap 51 :order #'>))))
    (assert (= 50 (treap-bisect-left treap 50 :order #'>)))
    (assert (= 40 (treap-bisect-left treap 49 :order #'>)))
    (assert (= 40 (treap-bisect-left treap 40 :order #'>)))
    (assert (null (treap-bisect-left treap 0 :order #'>)))))
