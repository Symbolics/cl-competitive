(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../explicit-treap.lisp"))

(use-package :test-util)

(defun treap-priority (treap)
  (declare ((or null treap) treap))
  (if (null treap)
      0
      (%treap-priority treap)))

(defun treap-sane-p (treap)
  (or (null treap)
      (and (>= (%treap-priority treap)
               (treap-priority (%treap-left treap)))
           (>= (%treap-priority treap)
               (treap-priority (%treap-right treap)))
           (= (%treap-count treap)
              (+ 1
                 (treap-count (%treap-left treap))
                 (treap-count (%treap-right treap))))
           (= (%treap-accumulator treap)
              (+ (%treap-value treap)
                 (treap-accumulator (%treap-left treap))
                 (treap-accumulator (%treap-right treap))))
           (treap-sane-p (%treap-left treap))
           (treap-sane-p (%treap-right treap)))))

(defun copy-treap (treap)
  "For development. Recursively copies the whole TREAP."
  (declare ((or null treap) treap))
  (if (null treap)
      nil
      (%make-treap (%treap-key treap)
                  (%treap-priority treap)
                  (%treap-value treap)
                  :accumulator (%treap-accumulator treap)
                  :left (copy-treap (%treap-left treap))
                  :right (copy-treap (%treap-right treap))
                  :count (%treap-count treap))))

(declaim (notinline make-treap treap-insert))

(with-test (:name explicit-treap-sanity)
  (loop repeat 10
        do (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10))))
           (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9))))
           (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17))))
           (assert (treap-sane-p (make-treap #(1 2 3 4))))
           (assert (treap-sane-p (make-treap #(1))))
           (assert (treap-sane-p nil))))

(with-test (:name explicit-treap-bisection)
  (let ((treap (treap-insert 50 3 (treap-insert 40 4 (treap-insert 20 1 nil :order #'>) :order #'>) :order #'>)))
    (assert (null (treap-bisect-right-1 51 treap :order #'>)))
    (assert (equal '(50 3) (multiple-value-list (treap-bisect-right-1 50 treap :order #'>))))
    (assert (= 50 (treap-bisect-right-1 49 treap :order #'>)))
    (assert (= 40 (treap-bisect-right-1 40 treap :order #'>)))
    (assert (= 20 (treap-bisect-right-1 0 treap :order #'>)))
    (assert (equal '(50 3) (multiple-value-list (treap-bisect-left 51 treap :order #'>))))
    (assert (= 50 (treap-bisect-left 50 treap :order #'>)))
    (assert (= 40 (treap-bisect-left 49 treap :order #'>)))
    (assert (= 40 (treap-bisect-left 40 treap :order #'>)))
    (assert (null (treap-bisect-left 0 treap :order #'>)))))
