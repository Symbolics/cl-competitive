(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../ref-able-treap.lisp"))

(use-package :test-util)

(defun copy-treap (treap)
  "For development. Recursively copies the whole TREAP."
  (declare ((or null treap) treap))
  (if (null treap)
      nil
      (%make-treap (%treap-key treap)
                   (%treap-priority treap)
                   :left (copy-treap (%treap-left treap))
                   :right (copy-treap (%treap-right treap))
                   :count (%treap-count treap))))

(defun treap-priority (treap)
  (declare ((or null treap) treap))
  (if (null treap)
      0
      (%treap-priority treap)))

(defun treap-sane-p (treap)
  (or (null treap)
      (and (>= (%treap-priority treap)
               (treap-priority (%treap-left treap)))
           (>= (%treap-priority treap)
               (treap-priority (%treap-right treap)))
           (= (%treap-count treap)
              (+ 1
                 (treap-count (%treap-left treap))
                 (treap-count (%treap-right treap))))
           (treap-sane-p (%treap-left treap))
           (treap-sane-p (%treap-right treap)))))

(declaim (notinline make-treap treap-split treap-insert treap-delete treap-ref treap-find))
(with-test (:name treap-sanity)
  (dotimes (_ 10)
    (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10))))
    (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9))))
    (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17))))
    (assert (treap-sane-p (make-treap #(1 2 3 4))))
    (assert (treap-sane-p (make-treap #(1))))
    (assert (treap-sane-p nil))))

(with-test (:name treap-fundamental)
  (multiple-value-bind (left right) (treap-split 5 (treap-insert 0 (treap-insert 10 (treap-insert 5 nil))))
    (assert (= 0 (%treap-key left)))
    (assert (null (%treap-left left)))
    (assert (null (%treap-right left)))
    (assert (or (typep (%treap-left right) 'treap)
                (typep (%treap-right right) 'treap))))

  (let ((treap1 (%make-treap 50 15 :count 5))
        (treap2 (%make-treap 100 11 :count 3)))
    (setf (%treap-left treap1) (%make-treap 30 5 :count 3))
    (setf (%treap-left (%treap-left treap1)) (%make-treap 20 2 :count 1))
    (setf (%treap-right (%treap-left treap1)) (%make-treap 40 4 :count 1))
    (setf (%treap-right treap1) (%make-treap 70 10 :count 1))
    (setf (%treap-right treap2) (%make-treap 200 3 :count 1))
    (setf (%treap-left treap2) (%make-treap 99 5 :count 1))
    ;; copy-treap
    (assert (equalp treap1 (copy-treap treap1)))
    (assert (not (eql treap1 (copy-treap treap1))))
    ;; split and merge
    (let ((treap (treap-merge (copy-treap treap1) (copy-treap treap2))))
      (assert (= 8 (%treap-count treap)))
      (multiple-value-bind (left right) (treap-split 80 (copy-treap treap))
        (assert (= 5 (%treap-count left)))
        (assert (= 3 (%treap-count right)))
        (assert (equalp treap (treap-merge left right)))))
    ;; find
    (assert (= 40 (treap-find 40 treap1)))
    (assert (null (treap-find 41 treap1)))
    ;; insert and delete
    (let ((inserted-treap1 (treap-insert 41 (copy-treap treap1))))
      (assert (= 41 (treap-find 41 inserted-treap1)))
      (let ((deleted-treap1 (treap-delete 41 inserted-treap1)))
        (assert (null (treap-find 41 deleted-treap1)))
        (assert (equalp treap1 deleted-treap1))
        (assert (equalp treap1 (treap-delete 41 deleted-treap1)))))
    (let ((treap (treap-merge treap1 treap2)))
      (assert (= 20 (treap-ref treap 0)))
      (assert (= 30 (treap-ref treap 1)))
      (assert (= 40 (treap-ref treap 2)))
      (assert (= 50 (treap-ref treap 3)))
      (assert (= 70 (treap-ref treap 4)))
      (assert (= 99 (treap-ref treap 5)))
      (assert (= 100 (treap-ref treap 6)))
      (assert (= 200 (treap-ref treap 7))))))

(with-test (:name treap)
  (let ((treap (make-treap #(1 2 3 5 7))))
    (assert (= 7 (treap-ref treap 4)))
    (assert (= 1 (treap-ref treap 0)))))
