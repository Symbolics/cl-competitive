(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../implicit-treap.lisp"))

(use-package :test-util)

(defun itreap-sane-p (itreap)
  (labels ((priority* (itreap)
             (if (null itreap) 0 (%itreap-priority itreap))))
    (declare (inline priority*))
    (if (null itreap)
        t
        (and (> (%itreap-priority itreap) (priority* (%itreap-left itreap)))
             (> (%itreap-priority itreap) (priority* (%itreap-right itreap)))
             (itreap-sane-p (%itreap-left itreap))
             (itreap-sane-p (%itreap-right itreap))))))

(with-test (:name implicit-treap-sanity)
  (assert (loop for i below 100 always (itreap-sane-p (make-itreap i)))))

(with-test (:name implicit-treap)
  (dotimes (i 10)
    (let ((itreap1 (itreap 1 2 3 2 1 2 7)))
      (let (res)
        (do-itreap (n itreap1) (push n res))
        (assert (equal (reverse res) '(1 2 3 2 1 2 7))))
      (assert (= 7 (itreap-ref itreap1 6)))
      (assert (= 1 (itreap-query itreap1 0 7)))
      (assert (= 2 (itreap-query itreap1 5 7)))
      (assert (= 2 (itreap-query itreap1 1 3)))
      (setf (itreap-ref itreap1 1) 0)
      (assert (= 0 (itreap-ref itreap1 1)))
      (assert (= most-positive-fixnum (itreap-query itreap1 1 1)))
      (assert (= 0 (itreap-query itreap1 0 3)))
      (assert (= 0 (itreap-query itreap1 0 7)))
      (assert (= 1 (itreap-query itreap1 2 7)))
      (assert (= 2 (itreap-query itreap1 2 4)))
      (signals invalid-itreap-index-error (itreap-query itreap1 2 8))
      (signals invalid-itreap-index-error (itreap-query itreap1 2 1))
      (signals invalid-itreap-index-error (itreap-ref itreap1 8))
      (signals invalid-itreap-index-error (setf (itreap-ref itreap1 8) 5)))))

(with-test (:name implicit-treap-ordered)
  (let ((itreap (itreap 3 3 2 2 2 2 1 1 1)))
    (assert (= 6 (itreap-bisect-left 1 itreap #'>)))
    (assert (= 9 (itreap-bisect-left 0 itreap #'>)))
    (assert (= 0 (itreap-bisect-left 4 itreap #'>)))))
