(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../implicit-treap.lisp"))

(use-package :test-util)

(defun inode-sane-p (inode)
  (labels ((priority* (inode)
             (if (null inode) 0 (%inode-priority inode))))
    (declare (inline priority*))
    (if (null inode)
        t
        (and (> (%inode-priority inode) (priority* (%inode-left inode)))
             (> (%inode-priority inode) (priority* (%inode-right inode)))
             (consistent-priorities-p (%inode-left inode))
             (consistent-priorities-p (%inode-right inode))))))

(with-test (:name implicit-treap-sanity)
  (assert (loop for i below 100 always (inode-sane-p (make-inode i)))))

(with-test (:name implicit-treap)
  (dotimes (i 10)
    (let ((itreap1 (inode 1 2 3 2 1 2 7)))
      (let (res)
        (do-inode (n itreap1) (push n res))
        (assert (equal (reverse res) '(1 2 3 2 1 2 7))))
      (assert (= 7 (inode-ref itreap1 6)))
      (assert (= 1 (inode-query itreap1 0 7)))
      (assert (= 2 (inode-query itreap1 5 7)))
      (assert (= 2 (inode-query itreap1 1 3)))
      (setf (inode-ref itreap1 1) 0)
      (assert (= 0 (inode-ref itreap1 1)))
      (assert (= 0 (inode-query itreap1 0 3)))
      (assert (= 0 (inode-query itreap1 0 7)))
      (assert (= 1 (inode-query itreap1 2 7))))))
